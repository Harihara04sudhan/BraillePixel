<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BraillePixel End-to-End Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-button {
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover { background: #0056b3; }
        .test-button:disabled { background: #6c757d; cursor: not-allowed; }
        .result {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .pass { background: #d4edda; color: #155724; }
        .fail { background: #f8d7da; color: #721c24; }
        .processing { background: #d1ecf1; color: #0c5460; }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
    </style>
</head>
<body>
    <h1>üß™ BraillePixel End-to-End Test</h1>
    <p>This tests all features with actual data to ensure production readiness.</p>
    
    <div class="test-section">
        <h2>üìã Quick Status</h2>
        <div id="overall-status" class="status processing">Initializing...</div>
        <button class="test-button" onclick="runAllTests()">üöÄ Run All Tests</button>
    </div>
    
    <div class="grid">
        <div class="test-section">
            <h3>üìù ASCII Text Art</h3>
            <button class="test-button" onclick="testASCII()">Test ASCII</button>
            <div id="ascii-status" class="status">Not tested</div>
            <div id="ascii-result" class="result" style="display:none;"></div>
        </div>
        
        <div class="test-section">
            <h3>üòÄ Emoji Text Art</h3>
            <button class="test-button" onclick="testEmojiText()">Test Emoji Text</button>
            <div id="emoji-text-status" class="status">Not tested</div>
            <div id="emoji-text-result" class="result" style="display:none;"></div>
        </div>
        
        <div class="test-section">
            <h3>üñºÔ∏è Braille Image Art</h3>
            <button class="test-button" onclick="testBrailleImage()">Test Braille</button>
            <div id="braille-status" class="status">Not tested</div>
            <div id="braille-result" class="result" style="display:none;"></div>
        </div>
        
        <div class="test-section">
            <h3>üé® Emoji Image Art</h3>
            <button class="test-button" onclick="testEmojiImage()">Test Emoji Image</button>
            <div id="emoji-image-status" class="status">Not tested</div>
            <div id="emoji-image-result" class="result" style="display:none;"></div>
        </div>
    </div>
    
    <div class="test-section">
        <h2>üìä Test Log</h2>
        <div id="test-log" class="result">Waiting for tests to start...\n</div>
    </div>
    
    <script src="script-simple.js"></script>
    <script>
        let testsPassed = 0;
        let totalTests = 0;
        
        function log(message) {
            const logEl = document.getElementById('test-log');
            const timestamp = new Date().toLocaleTimeString();
            logEl.textContent += `[${timestamp}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }
        
        function updateStatus(elementId, status, className) {
            const el = document.getElementById(elementId);
            el.textContent = status;
            el.className = `status ${className}`;
        }
        
        function showResult(elementId, content) {
            const el = document.getElementById(elementId);
            el.textContent = content;
            el.style.display = 'block';
        }
        
        async function testASCII() {
            log('üìù Testing ASCII text generation...');
            updateStatus('ascii-status', 'Processing...', 'processing');
            totalTests++;
            
            try {
                if (typeof generateASCIIText !== 'function') {
                    throw new Error('generateASCIIText function not found');
                }
                
                const testText = 'HELLO';
                const result = generateASCIIText(testText, 'block', true, false);
                
                if (!result || result.length === 0) {
                    throw new Error('No output generated');
                }
                
                if (!result.includes('‚ñà') && !result.includes('‚ñÄ') && !result.includes('‚ñÑ')) {
                    throw new Error('Output does not contain expected block characters');
                }
                
                const lines = result.split('\\n').length;
                log(`‚úÖ ASCII test passed - Generated ${lines} lines`);
                updateStatus('ascii-status', `‚úÖ PASS - ${lines} lines generated`, 'pass');
                showResult('ascii-result', result);
                testsPassed++;
                
            } catch (error) {
                log(`‚ùå ASCII test failed: ${error.message}`);
                updateStatus('ascii-status', `‚ùå FAIL - ${error.message}`, 'fail');
            }
            
            updateOverallStatus();
        }
        
        async function testEmojiText() {
            log('üòÄ Testing emoji text generation...');
            updateStatus('emoji-text-status', 'Processing...', 'processing');
            totalTests++;
            
            try {
                if (typeof generateTextToEmoji !== 'function') {
                    throw new Error('generateTextToEmoji function not found');
                }
                
                const result = generateTextToEmoji('HI', 'üî•', '‚ö™');
                
                if (!result || result.length === 0) {
                    throw new Error('No output generated');
                }
                
                if (!result.includes('üî•') && !result.includes('‚ö™')) {
                    throw new Error('Output does not contain expected emojis');
                }
                
                const lines = result.split('\\n').length;
                log(`‚úÖ Emoji text test passed - Generated ${lines} lines`);
                updateStatus('emoji-text-status', `‚úÖ PASS - ${lines} lines generated`, 'pass');
                showResult('emoji-text-result', result);
                testsPassed++;
                
            } catch (error) {
                log(`‚ùå Emoji text test failed: ${error.message}`);
                updateStatus('emoji-text-status', `‚ùå FAIL - ${error.message}`, 'fail');
            }
            
            updateOverallStatus();
        }
        
        async function testBrailleImage() {
            log('üñºÔ∏è Testing braille image processing...');
            updateStatus('braille-status', 'Processing...', 'processing');
            totalTests++;
            
            try {
                if (typeof processImageToBraille !== 'function') {
                    throw new Error('processImageToBraille function not found');
                }
                
                // Create a test image
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                // Draw a simple pattern
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 100, 100);
                ctx.fillStyle = 'black';
                ctx.fillRect(20, 20, 60, 60);
                
                // Convert canvas to blob
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
                
                // Create a File object
                const file = new File([blob], 'test.png', { type: 'image/png' });
                
                // Test the processing function
                return new Promise((resolve, reject) => {
                    const mockOutput = {
                        textContent: '',
                        set textContent(value) {
                            this._content = value;
                            
                            // Check if processing is complete
                            if (value && value !== 'Processing image...' && !value.includes('Error')) {
                                try {
                                    if (value.length === 0) {
                                        reject(new Error('No braille output generated'));
                                        return;
                                    }
                                    
                                    // Check for braille characters (Unicode range 0x2800-0x28FF)
                                    const hasBraille = /[‚†Ä-‚£ø]/.test(value);
                                    if (!hasBraille) {
                                        reject(new Error('Output does not contain braille characters'));
                                        return;
                                    }
                                    
                                    const lines = value.split('\\n').length;
                                    log(`‚úÖ Braille test passed - Generated ${lines} lines of braille`);
                                    updateStatus('braille-status', `‚úÖ PASS - ${lines} lines generated`, 'pass');
                                    showResult('braille-result', value);
                                    testsPassed++;
                                    resolve();
                                    
                                } catch (error) {
                                    reject(error);
                                }
                            } else if (value.includes('Error')) {
                                reject(new Error(value));
                            }
                        },
                        get textContent() {
                            return this._content || '';
                        }
                    };
                    
                    processImageToBraille(file, 20, 12, 127, false, mockOutput);
                    
                    // Timeout after 5 seconds
                    setTimeout(() => {
                        if (mockOutput.textContent === 'Processing image...') {
                            reject(new Error('Processing timeout'));
                        }
                    }, 5000);
                });
                
            } catch (error) {
                log(`‚ùå Braille test failed: ${error.message}`);
                updateStatus('braille-status', `‚ùå FAIL - ${error.message}`, 'fail');
            }
            
            updateOverallStatus();
        }
        
        async function testEmojiImage() {
            log('üé® Testing emoji image processing...');
            updateStatus('emoji-image-status', 'Processing...', 'processing');
            totalTests++;
            
            try {
                if (typeof processImageToEmojiBinary !== 'function') {
                    throw new Error('processImageToEmojiBinary function not found');
                }
                
                // Create a test image
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                // Draw a pattern
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 100, 100);
                ctx.fillStyle = 'black';
                ctx.fillRect(30, 30, 40, 40);
                
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });
                
                const file = new File([blob], 'test.png', { type: 'image/png' });
                
                return new Promise((resolve, reject) => {
                    const mockOutput = {
                        textContent: '',
                        set textContent(value) {
                            this._content = value;
                            
                            if (value && value !== 'Processing image...' && !value.includes('Error')) {
                                try {
                                    if (value.length === 0) {
                                        reject(new Error('No emoji output generated'));
                                        return;
                                    }
                                    
                                    if (!value.includes('üî•') && !value.includes('‚ö™')) {
                                        reject(new Error('Output does not contain expected emojis'));
                                        return;
                                    }
                                    
                                    const lines = value.split('\\n').length;
                                    log(`‚úÖ Emoji image test passed - Generated ${lines} lines`);
                                    updateStatus('emoji-image-status', `‚úÖ PASS - ${lines} lines generated`, 'pass');
                                    showResult('emoji-image-result', value);
                                    testsPassed++;
                                    resolve();
                                    
                                } catch (error) {
                                    reject(error);
                                }
                            } else if (value.includes('Error')) {
                                reject(new Error(value));
                            }
                        },
                        get textContent() {
                            return this._content || '';
                        }
                    };
                    
                    processImageToEmojiBinary(file, 20, 'üî•', '‚ö™', 128, mockOutput);
                    
                    setTimeout(() => {
                        if (mockOutput.textContent === 'Processing image...') {
                            reject(new Error('Processing timeout'));
                        }
                    }, 5000);
                });
                
            } catch (error) {
                log(`‚ùå Emoji image test failed: ${error.message}`);
                updateStatus('emoji-image-status', `‚ùå FAIL - ${error.message}`, 'fail');
            }
            
            updateOverallStatus();
        }
        
        function updateOverallStatus() {
            const overallEl = document.getElementById('overall-status');
            
            if (totalTests === 0) {
                overallEl.textContent = 'Ready to test';
                overallEl.className = 'status';
                return;
            }
            
            if (testsPassed === totalTests) {
                overallEl.textContent = `üéâ All ${totalTests} tests passed! Ready for deployment!`;
                overallEl.className = 'status pass';
            } else if (testsPassed === 0) {
                overallEl.textContent = `‚ùå ${totalTests - testsPassed} of ${totalTests} tests failed`;
                overallEl.className = 'status fail';
            } else {
                overallEl.textContent = `‚ö†Ô∏è ${testsPassed} of ${totalTests} tests passed`;
                overallEl.className = 'status processing';
            }
        }
        
        async function runAllTests() {
            log('üöÄ Starting comprehensive test suite...');
            testsPassed = 0;
            totalTests = 0;
            
            // Reset all status
            const statusElements = document.querySelectorAll('.status');
            statusElements.forEach(el => {
                if (el.id !== 'overall-status') {
                    el.textContent = 'Waiting...';
                    el.className = 'status processing';
                }
            });
            
            // Hide all results
            const resultElements = document.querySelectorAll('.result');
            resultElements.forEach(el => {
                if (el.id !== 'test-log') {
                    el.style.display = 'none';
                }
            });
            
            updateStatus('overall-status', 'Running tests...', 'processing');
            
            // Run tests sequentially to avoid interference
            await testASCII();
            await new Promise(resolve => setTimeout(resolve, 100));
            await testEmojiText();
            await new Promise(resolve => setTimeout(resolve, 100));
            await testBrailleImage();
            await new Promise(resolve => setTimeout(resolve, 100));
            await testEmojiImage();
            
            log(`üèÅ Test suite completed: ${testsPassed}/${totalTests} tests passed`);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ End-to-end test suite loaded');
            log('Ready to test all BraillePixel features');
            
            // Check if main functions are available
            const requiredFunctions = [
                'generateASCIIText',
                'generateTextToEmoji', 
                'processImageToBraille',
                'processImageToEmojiBinary'
            ];
            
            const missing = requiredFunctions.filter(func => typeof window[func] !== 'function');
            
            if (missing.length > 0) {
                log(`‚ö†Ô∏è Warning: Missing functions: ${missing.join(', ')}`);
                updateStatus('overall-status', `Missing functions: ${missing.join(', ')}`, 'fail');
            } else {
                log('‚úÖ All required functions are available');
                updateStatus('overall-status', 'All functions loaded - Ready to test!', 'pass');
            }
        });
    </script>
</body>
</html>
